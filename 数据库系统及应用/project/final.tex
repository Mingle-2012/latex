\documentclass[UTF8,openany]{ctexbook}

% 论文版面要求:
% 统一按 word 格式A4纸（页面设置按word默认值）编排、打印、制作。
% 正文内容字体为宋体；字号为小4号；字符间距为标准；行距为25磅(约0.88175cm)。

%%%%% ===== 页面设置
\usepackage[a4paper,top=2.54cm,bottom=2.54cm,left=3.17cm,right=3.17cm,%
            ]{geometry}
\usepackage{tcolorbox}
\usepackage{colortbl}
\usepackage{dirtree}
\usepackage{longtable}
\usepackage{booktabs}
            
\setlength{\parindent}{2em}
%默认的弹性间距会导致文中某些排版flush的时候，出现大量空白。
\setlength{\parskip}{0.5em} %指定固定段后间距，默认为弹性间距。
\setlength{\intextsep}{10pt} %固定浮浮动体前后间距。
\usepackage{enumitem}
\usepackage{ulem}

%%%%% =====章节 标题 设置
\ctexset{%
  contentsname={\vspace{-3.5em}\centerline{\zihao{-3}\heiti 目\quad 录}\vspace{-0.7em}},
  listfigurename={\vspace{-3.5em}\centerline{\zihao{-3}\heiti 插\ 图\ 目\ 录}\vspace{-0.5em}},
  listtablename={\vspace{-3.5em}\centerline{\zihao{-3}\heiti 表\ 格\ 目\ 录}\vspace{-0.5em}},
  bibname={\vspace{-3em}\centerline{\zihao{-3}\heiti 参\ 考\ 文\ 献}\vspace{3em}},
  chapter={name={,},
  number=\arabic{chapter}, %指定章序号为一二三。。。。
  nameformat={\zihao{-2}\bfseries},
  titleformat={\zihao{-2}\bfseries},
  format=\raggedright,
  beforeskip={10pt},
  afterskip={10pt},
  pagestyle={fancy}
  },
section={format=\raggedright,
  nameformat={\zihao{4}\bfseries},
  titleformat={\zihao{4}\bfseries},
%           afterskip={1ex plus 0.2ex}
  beforeskip={1ex},% 固定段前段后间距，
  afterskip={1ex}
  },
subsection={format=\raggedright,
  nameformat={\zihao{-4}\bfseries},
  titleformat={\zihao{-4}\bfseries},
%           afterskip={0.5ex plus 0.1ex}
  beforeskip={0.5ex},
  afterskip={0.5ex}
  }
}
%%%%% ===== 中英文字体
%\setsansfont{Myriad Pro} % 无衬线字体 sans serif \sffamily
%\setmonofont{Consolas}   % 等宽字体 typewriter \ttfamily
%\newcommand{\Times}{\fontspec{Times New Roman}}
%% 中文字体
%\setCJKmainfont[BoldFont={Microsoft YaHei},ItalicFont={KaiTi}]{NSimSun}
%\setCJKsansfont{Microsoft YaHei}
%\setCJKmonofont{KaiTi}
%\setCJKfamilyfont{STSong}{方正小标宋_GBK}\newcommand{\STSong}{\CJKfamily{STSong}}
\setCJKfamilyfont{songti}{STZhongsong}\newcommand{\STSong}{\CJKfamily{STSong}}

%%%%% ===== 常用宏包
\usepackage{amsmath,amssymb,amsfonts,bm}
\usepackage[amsmath,thref,thmmarks,hyperref]{ntheorem}
\usepackage{graphicx,xcolor,float}
\usepackage{fancyhdr}
\usepackage{tocloft} % 设置目录中的条目间距


\renewcommand\cftdot{\textsubscript{……}}
\renewcommand\cftdotsep{0}

\setlength{\cftbeforechapskip}{1pt}
\renewcommand{\cftchapleader}{\cftdotfill{\cdot}}


\usepackage{booktabs} % toprule, midrule, bottomrule
\usepackage{varwidth} % 可变宽度的 parbox

% %%%%% ===== 参考文献与链接
% \usepackage[numbers,sort&compress,sectionbib,super, square]{natbib} %引用上标，禁用连续缩写。
% \newcommand{\upcite}[1]{\textsuperscript{\cite{#1}}}


\usepackage[xetex,pagebackref]{hyperref}
\hypersetup{CJKbookmarks=true,colorlinks=true,citecolor=blue,%
            linkcolor=blue,urlcolor=blue,bookmarksnumbered=true,%
	        bookmarksopen=true,breaklinks=true}
	        
	        
	        
\iffalse   % 调试时，可去掉，以用于显示引用位置。
\renewcommand*{\backrefalt}[4]{%
\ifcase #1 No citations.%
\or Cited on page #2.%
\else Cited on pages #2.%
%\else #1 Cited on pages #2.%
\fi
}

\else
\renewcommand*{\backrefalt}[4]{}
\fi

%%%%% ===== 浮动图表的标题
\usepackage[margin=2em,labelsep=space,skip=0.5em,font=normalfont]{caption}
\DeclareCaptionFormat{mycaption}{{\heiti\color{blue} #1}#2{\kaishu #3}}
\captionsetup{format=mycaption,tablewithin=chapter,figurewithin=chapter}%,belowskip=-10pt
%\setlength{\belowcaptionskip}{-10pt}

%%%%%% ===== 浮动图表的比例默认50%以下，否则无法浮动。
\renewcommand\floatpagefraction{.9} %当浮动体小于页面90%时进行直接放置。
\renewcommand\topfraction{.9}  
\renewcommand\bottomfraction{.9}  
\renewcommand\textfraction{.1}



%%%%% ===== 算法
\usepackage{algorithm,algpseudocode}

%%%%% ===== 其他
\usepackage{ulem}
\def\ULthickness{1pt}




%%%%%===== Code Style代码
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{accsupp}



\newcommand\emptyaccsupp[1]{\BeginAccSupp{ActualText={}}#1\EndAccSupp{}}

\lstset{
    % language = C,
    showstringspaces=false,
    xleftmargin = 3em,xrightmargin = 3em, aboveskip = 1em,
	backgroundcolor = \color{white}, % 背景色
	basicstyle = \small\ttfamily, % 基本样式 + 小号字体
	rulesepcolor= \color{gray}, % 代码块边框颜色
	breaklines = true, % 代码过长则换行
	numbers = left, % 行号在左侧显示
	numberstyle=\emptyaccsupp,
    numbersep = 14pt, 
    keywordstyle=\color{purple}\bfseries, % 关键字颜色
    commentstyle =\color{red!50!green!50!blue!60}, % 注释颜色
    stringstyle = \color{red}, % 字符串颜色
    morekeywords={ASSERT, int64_t, uint32_t},
	% frame = shadowbox, % 用(带影子效果)方框框住代码块
	frame = single, % 用(带影子效果)方框框住代码块
	showspaces = false, % 不显示空格
	columns = fixed, % 字间距固定
  framesep=1em
} 
\lstset{
    sensitive=true,
    moreemph={ASSERT, NULL}, emphstyle=\color{red}\bfseries,
    moreemph=[2]{int64_t, uint32_t, tid_t, uint8_t, int16_t, uint16_t, int32_t, size_t}, emphstyle=[2]\color{purple}\bfseries,
    showspaces = false, % 不显示空格
    }



\newcommand{\mcc}[1]{\multicolumn{1}{c}{\underline{\makebox[10em][c]{#1}}}}
\newcommand{\mce}[1]{\multicolumn{1}{c}{\underline{\makebox[15em][l]{#1}}}}


\pagestyle{fancy}
\fancyhf{}  % 清除以前对页眉页脚的设置

\newcommand{\makeheadrule}{%% 定义页眉与正文间双隔线
    \makebox[0pt][l]{\rule[.7\baselineskip]{\headwidth}{0.3pt}}%0.4
    \rule[0.85\baselineskip]{\headwidth}{1.0pt}\vskip-.8\baselineskip}
\makeatletter
\renewcommand{\headrule}{%
    % {\if@fancyplain\let\headrulewidth\plainheadrulewidth\fi\makeheadrule}}
    {\makeheadrule}}
\makeatother
\renewcommand{\chaptermark}[1]{\markboth{\CTEXthechapter \ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
%\fancyhead[RO,LE]{{\small\songti\rightmark}}     % 节标题
%\fancyhead[RE]{{\small\songti\leftmark}}      % 章标题
\fancyhead[L]{《数据库系统及应用实践》课程项目报告}
\fancyhead[R]{COVIDLIT SEARCH}
% \fancyhead[RO,LE]{$\cdot$ {\small\thepage} $\cdot$}
\fancyfoot[C]{{-\thepage-}}
%\fancyfoot[CO,CE]{{\thepage}}

\ctexset{chapter/break={}}

\begin{document}

\begin{titlepage}
    \begin{center}

        {
            \begin{figure}[H]
                \vspace{5cm}
                \includegraphics[width=14cm]{img/0.png}
            \end{figure}
            \heiti\zihao{2}《数据库系统及应用实践》课程项目报告\\
            \vspace{0.8em}
            \zihao{2}\textbf{CovidLit Search}\Large{(Final Report)}
        }
        \\[10em]
        \zihao{-3}
        \begin{tabular}{p{0cm}p{5.5em}@{\extracolsep{0.5ex}}cc}
            ~ & \hfill 小\ 组\ 成\ 员： &  & \mcc{李鹏达\quad 10225101460}      \\
            ~ & \hfill             &  & \mcc{武泽恺\quad 10225101429}      \\
            ~ & \hfill             &  & \mcc{王\quad 力\quad 10225101434} \\
        \end{tabular}
        \\[8em]
        \zihao{-2}2024年5月 - 6月
    \end{center}
    \thispagestyle{fancy}
    \fancyfoot[C]{}
\end{titlepage}
\fancyfoot[C]{-\thepage-}

\setcounter{page}{1}
\pagenumbering{roman}
\tableofcontents
\thispagestyle{fancy}
\newpage

\setcounter{page}{1}
\pagenumbering{arabic}

\chapter{项目简介}

本项目（“CovidLit Search”）致力于为研究人员提供一个方便的、用户友好的COVID-19相关文献检索工具，以帮助他们更快地找到相关文献进行参考研究。

本项目的目标是通过提供一个简单友好的界面，使用户能够快速搜索到与COVID-19相关的文献，并且能够根据作者、时间和期刊等信息进行检索。此外，本项目也允许用户通过研究方向、研究对象和研究问题等信息准确检索部分文献并对其他文献进行模糊搜索，以便用户查找到最相关的文献。

另外，本项目还提供了一个用户注册和登录系统。用户可以通过注册登录后，将自己的搜索历史保存在云端，以便在不同设备上查看自己的搜索历史。用户还可以将自己感兴趣的文献加入到自己的收藏夹中或订阅期刊，以便在以后查看。

本项目名称为 ""CovidLit Search''，意为 ""COVID-19 Literature Search''，即 COVID-19 相关文献检索。

\chapter{数据库设计}

\section{概述}
\label{sec:overviewOfDatabaseDesign}

为了实现文献检索系统，我们需要设计一个数据库来存储文献、期刊、作者和引用等信息。

为了实现相关功能，我们考虑使用 Entity-Relation 模型来设计数据库。我们考虑设计文章(article)、作者(author)、期刊(journal)和用户(user)等实体集，以及撰写(write)、引用(cite)、订阅(subscribe)、收藏(collect)和浏览历史(history)等联系集。

其中，文章(article)与作者(author)通过撰写(write)联系集相连，表示作者撰写了文章；文章(article)与期刊(journal)通过发表(publish)联系集相连，表示文章在期刊上发表；文章(article)与文章(article)通过引用(cite)联系集相连，标识不同文章之间的引用与被引用关系；用户(user)与文章(article)通过收藏(collect)浏览历史(history)联系集相连，表示用户收藏了文章和用户的历史浏览文章；用户(user)与期刊(journal)通过订阅(subscribe)联系集相连，表示作者订阅了该期刊，可能希望获取该期刊的最新文章。

起初，我们考虑使用 MySQL 数据库来存储数据，并成功地将小数据集的数据导入了数据库中，完成了基本的测试。但在完成实验5后，我们发现 PostgreSQL 在多表的复杂查询上的性能要明显优于 MySQL，在数据规模较大的完整数据集上，PostgreSQL 的性能可能会更优。因此，我们决定改用 PostgreSQL 数据库来存储数据。

\section{表结构}

\subsection{实体集}
\label{sec:entities}

用户(user)表存储用户的基本信息，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{id} & \texttt{INT} & 是 &  & 用户ID，自动递增 \\
        \hline
        \textit{nickname} & \texttt{VARCHAR(100)} &  &  & 用户名（昵称） \\
        \hline
        \textit{email} & \texttt{VARCHAR(200)} &  &  & 邮箱 \\
        \hline
        \textit{password} & \texttt{VARCHAR(100)} &  &  & 密码（加密后） \\
        \hline
        \textit{avatar} & \texttt{VARCHAR(500)} &  &  & 头像 \\
        \hline
        \textit{motto} & \texttt{VARCHAR(1000)} &  &  & 座右铭 \\
        \hline
        \textit{collage} & \texttt{VARCHAR(100)} &  &  & 学院（学校） \\
        \hline
        \textit{subscribe\_email} & \texttt{BOOLEAN} &  &  & 是否订阅邮件 \\
        \hline
        \textit{save\_history} & \texttt{BOOLEAN} &  &  & 是否保存历史记录 \\
        \hline
    \end{tabular}
    \caption{用户(\textit{user})表}
\end{table}

文章(article)表存储文章的基本信息，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{id} & \texttt{VARCHAR(50)} & 是 &  & 文章ID \\
        \hline
        \textit{title} & \texttt{VARCHAR(1000)} &  &  & 文章标题 \\
        \hline
        \textit{abstract} & \texttt{TEXT} &  &  & 摘要 \\
        \hline
        \textit{doi} & \texttt{VARCHAR(50)} &  &  & 数字对象唯一标识符 \\
        \hline
        \textit{license} & \texttt{VARCHAR(50)} &  &  & 许可 \\
        \hline
        \textit{publish\_time} & \texttt{DATETIME} &  &  & 发表时间 \\
        \hline
        \textit{url} & \texttt{VARCHAR(800)} &  &  & 文章URL \\
        \hline
        \textit{study\_type} & \texttt{VARCHAR(500)} &  &  & 研究类型 \\
        \hline
        \textit{addressed\_population} & \texttt{VARCHAR(1000)} &  &  & 研究对象人群 \\
        \hline
        \textit{challenge} & \texttt{VARCHAR(2000)} &  &  & 挑战/研究问题 \\
        \hline
        \textit{focus} & \texttt{VARCHAR(100)} &  &  & 研究重点 \\
        \hline
        \textit{authors} & \texttt{text} &  &  & 作者 \\
        \hline
    \end{tabular}
    \caption{文章(\textit{article})表}
\end{table}

期刊(journal)表存储期刊的基本信息，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{name} & \texttt{VARCHAR(100)} & 是 &  & 期刊名称 \\
        \hline
        \textit{description} & \texttt{VARCHAR(1000)} &  &  & 期刊描述 \\
        \hline
    \end{tabular}
    \caption{期刊(\textit{journal})表}
\end{table}

作者(author)表存储作者的基本信息，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{name} & \texttt{VARCHAR(100)} & 是 &  & 作者姓名 \\
        \hline
        \textit{email} & \texttt{VARCHAR(1000)} &  &  & 邮箱 \\
        \hline
        \textit{lab} & \texttt{VARCHAR(1000)} &  &  & 所在实验室 \\
        \hline
        \textit{institution} & \texttt{VARCHAR(1000)} &  &  & 所在机构 \\
        \hline
        \textit{country} & \texttt{VARCHAR(100)} &  &  & 国家 \\
        \hline
        \textit{post\_code} & \texttt{VARCHAR(100)} &  &  & 邮政编码 \\
        \hline
        \textit{settlement} & \texttt{VARCHAR(100)} &  &  & 定居点（城市） \\
        \hline
    \end{tabular}
    \caption{作者(\textit{author})表}
\end{table}

\subsection{联系集}

撰写(write)联系集存储文章与作者之间的联系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{author\_name} & \texttt{VARCHAR(100)} & 是 & \textit{author(name)} & 作者姓名 \\
        \hline
        \textit{article\_id} & \texttt{VARCHAR(50)} & 是 & \textit{article(id)} & 文章ID \\
        \hline
    \end{tabular}
    \caption{撰写关系(\textit{write})表}
\end{table}

发表(publish)联系集存储文章与期刊之间的联系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
    \hline
    \textit{journal\_name} & \texttt{VARCHAR(100)} & 是 & \textit{journal(name)} & 期刊名称 \\
    \hline
    \textit{article\_id} & \texttt{VARCHAR(50)} & 是 & \textit{article(id)} & 文章ID \\
    \hline
    \textit{volume} & \texttt{VARCHAR(50)} & & & 卷号 \\
    \hline
    \textit{pages} & \texttt{VARCHAR(200)} & & & 页码 \\
    \hline
    \end{tabular}
    \caption{发表关系(\textit{publish})表}
\end{table}


引用(cite)联系集存储文章与文章之间的引用关系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{citing\_id} & \texttt{VARCHAR(100)} & 是 & \textit{article(id)} & 引用文章ID \\
        \hline
        \textit{cited\_id} & \texttt{VARCHAR(100)} & 是 & \textit{article(id)} & 被引用文章ID \\
        \hline
    \end{tabular}
    \caption{引用关系(\textit{cite})表}
\end{table}

收藏(collect)联系集存储用户与文章之间的收藏关系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{user\_id} & \texttt{INT} & 是 & \textit{user(id)} & 用户ID \\
        \hline
        \textit{article\_id} & \texttt{VARCHAR(50)} & 是 & \textit{article(id)} & 文章ID \\
        \hline
    \end{tabular}
    \caption{收藏关系(\textit{collect})表}
\end{table}

订阅(subscribe)联系集存储用户与期刊之间的订阅关系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{user\_id} & \texttt{INT} & 是 & \textit{user(id)} & 用户ID \\
        \hline
        \textit{journal\_name} & \texttt{VARCHAR(200)} & 是 & \textit{journal(name)} & 期刊名称 \\
        \hline
    \end{tabular}
    \caption{订阅关系(\textit{subscribe})表}
\end{table}

浏览历史(history)联系集存储用户与文章之间的浏览历史关系，其结构如下：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{user\_id} & \texttt{INT} & 是 & \textit{user(id)} & 用户ID \\
        \hline
        \textit{article\_id} & \texttt{VARCHAR(50)} & 是 & \textit{article(id)} & 文章ID \\
        \hline
        \textit{time} & \texttt{DATETIME} & 是 &  & 浏览时间 \\
        \hline
    \end{tabular}
    \caption{浏览历史(\textit{history})表}
\end{table}

\section{E-R 图}
\label{sec:er}



根据上述设计，我们绘制了数据库的 E-R 图，如图 \ref{fig:er} 所示。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/ER.png}
    \caption{数据库 E-R 图}
    \label{fig:er}
\end{figure}

其中，PK 表示主键，FK 表示外键。

\section{\texttt{schema}}
\label{sec:schema}

根据上述设计，我们可以写出数据库的 \texttt{schema}，如下所示：

\begin{tcolorbox}
    \raggedright
    \hangafter=1
    \hangindent=3em
    \it
    article(\uline{id}, title, abstract, doi, license, publish\_time, url, study\_type, addressed\_population,
    challenge, focus, authors)

    author(\uline{name}, email, lab, institution, country, post\_code, settlement)

    write(\uline{author\_name}, \uline{article\_id})

    journal(\uline{name}, description)

    publish(\uline{journal\_name}, \uline{article\_id}, volume, pages)

    cite(\uline{citing\_id}, \uline{cited\_id})

    \hangafter=1
    \hangindent=2em
    user(\uline{id}, nickname, email, password, avatar, motto, collage, subscribe\_email, save\_history, role, salt)

    collect(\uline{user\_id}, \uline{article\_id})

    subscribe(\uline{user\_id}, \uline{journal\_name})

    history(\uline{user\_id}, \uline{article\_id}, time)
\end{tcolorbox}



\chapter{数据集}

\section{数据来源}

本项目使用的数据集是由美国白宫联合一系列顶尖研究机构提供的COVID-19 Open Research Dataset (CORD-19)。该数据集可以在Kaggle上下载\footnote{\url{https://www.kaggle.com/datasets/allen-institute-for-ai/CORD-19-research-challenge}}，它包含了超过1,000,000篇来自PubMed、PMC、bioRxiv和medRxiv等来源的COVID-19相关文献的元数据，其中400,000篇提供全文。此外，该数据集还包括超过 6,000篇按研究方向分类的文献元数据，包括研究方向、研究对象和研究问题等信息。

该数据集的元数据包括文献标题、作者、摘要、发布时间、期刊、全文链接等信息。我们将使用这些信息来构建我们的文献检索系统。


\section{数据处理}

\subsection{数据集结构}

我们首先对数据集进行了初步的探索，其结构如图 \ref{fig:dataset} 所示。数据集主要包括以下几个部分：

\begin{enumerate}
    \item \texttt{metadata.csv}：包含了文献的元数据，包括文献标题、作者、摘要、发布时间、期刊、全文链接等信息。
    \item \texttt{metadata.readme}：包含数据集内容的更新日志。
    \item \texttt{json\_schema.txt}：包含了数据集中的\texttt{JSON}文件的结构。
    \item \texttt{COVID.DATA.LIC.AGMT.pdf}：包含了数据集的使用许可协议。
    \item \texttt{document\_parses/}：文件夹，包含了数据集中的文献全文，以\texttt{JSON}格式存储。
    \item \texttt{Kaggle/target\_tables/}：文件夹，包含了数据集中的研究方向分类的文献元数据，包括研究方向、研究对象和研究问题等信息。
    \item \texttt{cord\_19\_embeddings/}：文件夹，包含了数据集中的文献的嵌入向量。

\end{enumerate}
\begin{figure}[H]
    \dirtree{%
        .1 archive.
        .2 metadata.csv\DTcomment{1}.
        .2 metadata.readme\DTcomment{2}.
        .2 json\_schema.txt\DTcomment{3}.
        .2 COVID.DATA.LIC.AGMT.pdf\DTcomment{4}.
        .2 document\_parses\DTcomment{5}.
        .3 pdf\_json.
        .4 $\cdots$ .
        .3 pmc\_json.
        .4 $\cdots$ .
        .2 Kaggle.
        .3 target\_tables\DTcomment{6}.
        .4 0\_table\_formats\_and\_column\_definitions.
        .4 1\_population.
        .5 $\cdots$ .
        .4 $\cdots$.
        .3 cord\_19\_embeddings\DTcomment{7}.
        .4 cord\_19\_embeddings-2022-06-02.csv.
    }
    \caption{数据集结构}
    \label{fig:dataset}
\end{figure}




\subsection{处理方式}

\label{sec:dataProcessing}

由于数据集较大，包含了大量无用信息，且格式不是我们期望的格式，我们需要对数据集进行预处理，提取出我们需要的信息，并插入数据库中。

我们使用 \texttt{Python} 脚本进行处理，处理方式如下：

\begin{enumerate}
    \item 创建一些存储过程或函数，用于简化后续大量数据的插入。
    \item 根据 \texttt{json\_schema.txt} 文件，对 \texttt{document\_parses/} 文件夹中的文献全文的 \texttt{JSON} 结构使用 \texttt{Python} 类进行建模，以便后续提取信息。
    \item 读取 \texttt{metadata.csv} 文件，对每一条文献的元数据进行处理。
    \begin{enumerate}
        \item 提取文献的基本信息，包括标题、摘要、发布时间、期刊等。
        \item 根据原数据中的文献全文地址，读取对应的全文文件。
        
        \begin{enumerate}
            \item 提取文献的详细作者信息，包括作者单位、邮箱、国籍等。
            \item 提取文献引用信息，包括引用文献的标题、作者、期刊、发布时间等。
        \end{enumerate}

        \item 将提取的信息存储到\texttt{.tbl}格式的本地文件中。
        \item 将\texttt{.tbl}文件导入数据库中。
    \end{enumerate}
    \item 读取 \texttt{Kaggle/target\_tables/} 文件夹中的研究方向分类的文献元数据。
    
    \begin{enumerate}
        \item 提取文献的研究方向、研究对象和研究问题等信息。
        \item 将提取的信息存储到数据库中。
    \end{enumerate}
\end{enumerate}

起初，我们采取的方案是使用 \texttt{Python} 脚本直接读取数据集中的文件并进行处理，每处理一篇文献就插入一次数据库，并使用数据库连接池与多线程来加速处理。但在使用全部数据集进行测试时，我们发现随着数据的插入，数据库的性能会逐渐下降，导致处理速度变慢。因此，我们改变了策略，将数据处理与数据插入分开，先将数据处理后存储到本地文件中，再使用数据库的 \texttt{COPY} 命令批量插入数据，以提高性能。


\section{数据量}

对于前期开发测试，我们使用数据集中的 $1000+5000$ 余篇文献进行测试。对于后期开发，我们将使用全部数据集（$1000000+5000$余篇文献）进行测试。最终，我们将使用全部数据集进行部署。

\chapter{功能设计}

\section{用户功能}

\begin{enumerate}
    \item 用户注册：用户可以通过邮箱注册账号。
    \item 用户登录：用户可以通过邮箱和密码登录账号。
    \item 用户修改密码：用户可以通过邮箱验证或旧密码修改密码。
    \item 用户信息修改：用户可以修改自己的昵称、头像、座右铭等信息。
    \item 用户订阅：用户可以订阅感兴趣的期刊。
    \item 用户收藏：用户可以收藏感兴趣的文献。
    \item 用户浏览历史：用户可以查看自己的浏览历史。
    \item 邮件订阅：用户可以订阅邮件，以从邮件中获取订阅的文献的更新。
\end{enumerate}

\section{搜索功能}

\begin{enumerate}
    \item 文献搜索：用户可以通过关键词搜索文献。
    \item 高级搜索：用户可以通过作者、时间、期刊等信息进行高级搜索。
    \item 研究方向搜索：用户可以通过研究方向、研究对象和研究问题等信息进行搜索。
    \item 文献推荐：系统可以根据用户的搜索历史推荐相关文献。
\end{enumerate}

\section{文献功能}

\begin{enumerate}
    \item 文献详情：用户可以查看文献的详细信息。
    \item 文献引用：用户可以查看文献的引用信息，包括引用与被引用，直接引用和间接引用。
    \item 文献跳转：用户可以跳转到文献全文所在的网址。
    \item 文献推荐：系统可以根据文献的内容推荐相关文献。
    \item 文献分享：用户可以将文献分享到社交媒体或邮件。
\end{enumerate}

\chapter{用户界面设计}

\section{首页}

首页包含搜索，用户注册、登录，文献推荐等功能，如图 \ref{fig:home} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.71\textwidth]{img/1.png}
\caption{首页}
\label{fig:home}
\end{figure}

用户在登入后，首页会显示用户昵称、头像等信息，并且可以跳转至用户个人主页、收藏、安全设置等页面，如图 \ref{fig:home-login} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.71\textwidth]{img/2.png}
\caption{首页（登录后）}
\label{fig:home-login}
\end{figure}

\section{搜索页}

用户在任意界面都可以进行搜索，搜索结果会显示在搜索页。搜索页包含搜索框、高级搜索、研究方向搜索等功能，用户可以对搜索结果进行排序，或对搜索结果进行筛选，如图 \ref{fig:search} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/3.png}
\caption{搜索页}
\label{fig:search}
\end{figure}

\section{文献详情页}

用户点击文献，将跳转至文献页。用户可以查看文献的详细信息，包括标题、作者、摘要、发布时间、期刊等信息。用户可以查看文献的引用信息，包括引用与被引用，直接引用和间接引用。用户也可以跳转到文献全文所在的网址。如图 \ref{fig:detail} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/4.png}
\caption{文献详情页}
\label{fig:detail}
\end{figure}

用户点击摘要、期刊、作者等栏目，可以展开查看更多相关信息，如图 \ref{fig:detail-more} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/5.png}
\caption{文献详情页（更多信息）}
\label{fig:detail-more}
\end{figure}

\section{注册与登录页}

用户在任意界面点击注册，将跳转至注册页。用户在注册页输入邮箱，通过验证码认证后，设置密码完成注册，如图 \ref{fig:register} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/7.png}
\caption{注册页}
\label{fig:register}
\end{figure}

用户在任意界面点击登录，将跳转至登录页。用户在登录页输入邮箱和密码，完成登录，如图 \ref{fig:login} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/6.png}
\caption{登录页}
\label{fig:login}
\end{figure}

\section{用户页面}

用户在任意界面点击用户信息按钮，将跳转至用户信息页面。在用户信息页面，用户可以查看和修改自己的个人信息，包括昵称、头像、座右铭、学院等信息。用户也可以修改个人信息偏好，如是否存储浏览历史等。如图 \ref{fig:user-info} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/8.png}
\caption{用户信息}
\label{fig:user-info}
\end{figure}

用户点击收藏按钮，将跳转至收藏页面。在收藏页面，用户可以查看自己收藏的文献，如图 \ref{fig:collect} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/9.png}
\caption{收藏}
\label{fig:collect}
\end{figure}

用户点击安全设置按钮，将跳转至安全设置页面。在安全设置页面，用户可以修改密码，如图 \ref{fig:security} 所示。

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/10.png}
\caption{安全设置}
\label{fig:security}
\end{figure}

\chapter{\texttt{SQL}}
\label{sec:sql}

在此部分，我们将展示部分 \texttt{SQL} 语句，用于实现系统相关功能。

由于数据量较大，我们考虑在查询时应该使用分页查询，以减少查询时间。我们使用 \texttt{LIMIT} 和 \texttt{OFFSET} 关键字来实现分页查询，例如，\texttt{LIMIT n OFFSET m}或\texttt{LIMIT m, n} 表示从第 $m+1$ 行开始取 $n$ 行数据。\textbf{为了使报告中的 \texttt{SQL} 语句更加简洁，我们在此省略了分页查询的部分}。

在下面的代码中，\texttt{SQL} 语句中的 \texttt{?} 表示占位符，用于接收用户输入的参数。

\section{用户相关功能}

根据用户邮箱和密码进行注册:

\begin{lstlisting}[language=SQL]
INSERT INTO "user" ("email", "password") VALUES (?, ?);
\end{lstlisting}

根据邮箱查询用户:

\begin{lstlisting}[language=SQL]
SELECT * FROM "user" WHERE email = ?;
\end{lstlisting}

根据用户传入的新密码和用户的id来修改密码:

\begin{lstlisting}[language=SQL]
UPDATE "user" SET "password" = ? WHERE "id" = ?;
\end{lstlisting}

根据用户传入修改信息来对原信息进行修改:

\begin{lstlisting}[language=SQL]
UPDATE "user" SET "nickname" = ?, "avatar" = ?, "motto" = ?, 
  "collage" = ?, "subscribe_email" = ? "save_history" = ? 
  WHERE "id" = ?;
\end{lstlisting}

根据用户的ID和期刊的名称实现用户订阅感兴趣的期刊:

\begin{lstlisting}[language=SQL]
INSERT INTO "subscribe" VALUES(?,?);
\end{lstlisting}

根据用户的ID和文献的ID用户实现收藏感兴趣的文献:

\begin{lstlisting}[language=SQL]
INSERT INTO "collect" VALUES(?,?); 
\end{lstlisting}

根据用户的ID来实现查看用户的浏览历史:

\begin{lstlisting}[language=SQL]
SELECT * FROM "history" WHERE "user_id" = ?;
\end{lstlisting}

\textbf{定时任务}——删除过期的浏览历史\footnote{需要安装\texttt{pg\_cron}插件}：

\begin{lstlisting}[language=sql]
CREATE EXTENSION pg_cron;
SELECT cron.schedule(
  'daily_clean_history',  
  '0 0 * * *',
  $$
  DELETE FROM history
  WHERE time < NOW() - INTERVAL '1 month';
  $$
);
\end{lstlisting}


\section{搜索相关功能}

根据作者姓名（模糊）搜索作者信息：

\begin{lstlisting}[language=sql]
SELECT * FROM "author" WHERE "name" LIKE "%?%";
\end{lstlisting}

根据作者姓名（模糊）搜索其撰写的文献：

\begin{lstlisting}[language=sql]
SELECT "author_name", "id", "title", "abstract","doi",
  "license", "publish_time", "url" 
FROM "write" JOIN "article" 
ON "article_id" = "id" 
WHERE "author_name" LIKE "%?%";
\end{lstlisting}

根据文献标题（模糊）搜索文献：

\begin{lstlisting}[language=sql]
SELECT "id", "title", "abstract", "doi", "license"
FROM (
  SELECT * 
  FROM "article"
  WHERE "title" LIKE "%?%"
) AS "art"
JOIN "publish" ON "id"="publish"."article_id"
JOIN "write" ON "id"="write"."article_id";
\end{lstlisting}

根据期刊名模糊搜索期刊：

\begin{lstlisting}[language=sql]
SELECT * 
FROM "journal" 
WHERE "journal"."name" LIKE "%?%";
\end{lstlisting}

根据期刊名模糊搜索该期刊刊登的文章：
\begin{lstlisting}[language=sql]
SELECT * 
FROM "publish" JOIN "article" ON "article_id" = "id"
WHERE "journal_name" LIKE "%?%";
\end{lstlisting}

根据研究方向、研究对象和研究问题搜索文献：
\begin{lstlisting}[language=sql]
SELECT "id", "title", "abstract", "doi", "license", 
  "publish_time", "url", "journal_name"
FROM (
  SELECT * 
  FROM "article"
  WHERE "study_type" LIKE "%?%"
  OR "addressed_population" LIKE "%?%"
  OR "challenge" LIKE "%?%"
  OR "focus" LIKE "%?%"
) AS "art"
JOIN "publish" ON "id"="publish"."article_id"
JOIN "write" ON "id"="write"."article_id";
\end{lstlisting}



\section{文献相关功能}

根据文献ID查询文献的详细信息：

\begin{lstlisting}[language=sql]
SELECT "id","title","abstract","doi","license","publish_time","url","study_type",
"addressed_population","challenge","focus","journal_name","volume","pages"
FROM "article" JOIN "publish" ON "id"="article_id"
WHERE "id" = ?;
\end{lstlisting}

根据文献ID查询作者：

\begin{lstlisting}[language=sql]
SELECT "write".author_name
FROM "article" JOIN "write" ON article_id = "id"
WHERE "id"= ?;
\end{lstlisting}

\textbf{函数}——插入被引用的文献：

\begin{lstlisting}[language=sql]
CREATE OR REPLACE FUNCTION "public"."insert_cited_art"(
  "aid" varchar, 
  "in_title" varchar, 
  "in_doi" varchar, 
  "in_publish_time" timestamptz, 
  "in_journal" varchar, 
  "in_volume" varchar, 
  "in_pages" varchar, 
  "authors" varchar
)
RETURNS "pg_catalog"."void" AS $BODY$
DECLARE
  cnt INT;
  current_author VARCHAR;
  position INT;
BEGIN
  SELECT COUNT(*) INTO cnt FROM article WHERE title = in_title;
  IF cnt = 0 THEN  
    BEGIN
      INSERT INTO article(id, title, doi, publish_time) VALUES(aid, in_title, in_doi, in_publish_time)
      ON CONFLICT (id) DO NOTHING;
    EXCEPTION WHEN unique_violation THEN   
    END;
    position := 1;
    WHILE POSITION(';' IN authors) > 0 LOOP
      current_author := SUBSTRING(authors, 1, POSITION(';' IN authors) - 1);
      BEGIN
        INSERT INTO author(name) VALUES(current_author)
        ON CONFLICT (name) DO NOTHING;
      EXCEPTION WHEN unique_violation THEN 
      END;
      BEGIN
        INSERT INTO write(author_name, article_id) VALUES(current_author, aid)
        ON CONFLICT (author_name, article_id) DO NOTHING;
      EXCEPTION WHEN unique_violation THEN 
      END;
      authors := SUBSTRING(authors, POSITION(';' IN authors) + 1);
    END LOOP;
    current_author := authors;
    BEGIN
      INSERT INTO author(name) VALUES(current_author)
      ON CONFLICT (name) DO NOTHING;
    EXCEPTION WHEN unique_violation THEN  
    END;
    BEGIN
      INSERT INTO write(author_name, article_id) VALUES(current_author, aid)
      ON CONFLICT (author_name, article_id) DO NOTHING;
    EXCEPTION WHEN unique_violation THEN  
    END;
    BEGIN
      INSERT INTO journal(name) VALUES(in_journal)
      ON CONFLICT (name) DO NOTHING;
    EXCEPTION WHEN unique_violation THEN    
    END;
    BEGIN
      INSERT INTO publish(journal_name, article_id, volume, pages) VALUES(in_journal, aid, in_volume, in_pages)
      ON CONFLICT (journal_name, article_id) DO NOTHING;
    EXCEPTION WHEN unique_violation THEN  
    END;
  END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
\end{lstlisting}

\textbf{函数}——插入扩展文章：

\begin{lstlisting}[language=sql]
CREATE OR REPLACE FUNCTION "public"."insert_extend_art"(
  "aid" varchar, 
  "in_title" varchar, 
  "in_publish_time" timestamptz, 
  "in_url" varchar, 
  "in_study_type" varchar, 
  "in_addressed_population" varchar, 
  "in_challenge" varchar, 
  "in_focus" varchar, 
  "in_journal" varchar
)
RETURNS "pg_catalog"."void" AS $BODY$
DECLARE
  cnt INT;
BEGIN
  SELECT COUNT(*) INTO cnt FROM article WHERE title = in_title;
  IF cnt = 0 THEN
    INSERT INTO article(id, title, publish_time, url, study_type, addressed_population, challenge, focus)
    VALUES(aid, in_title, in_publish_time, in_url, in_study_type, in_addressed_population, in_challenge, in_focus)
    ON CONFLICT (id) DO NOTHING;
    INSERT INTO journal(name) VALUES (in_journal)
    ON CONFLICT (name) DO NOTHING;
    INSERT INTO publish(journal_name, article_id, volume, pages)
    VALUES(in_journal, aid, NULL, NULL)
    ON CONFLICT (journal_name, article_id) DO NOTHING;
  END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
\end{lstlisting}

\textbf{递归查询}——查询文献的直接引用和间接引用：

\begin{lstlisting}[language=sql]
WITH RECURSIVE "c" AS (
  SELECT "citing_id", "cited_id", 0 AS "flag" FROM "cite"
  WHERE "citing_id" = ?
  UNION
  SELECT "citing_id", "id", 1 AS "flag" FROM "c" JOIN "article"
  ON "c"."cited_id" = "article"."id"
) 
SELECT * FROM "c";
\end{lstlisting}

\chapter{测试与性能}
\label{sec:performance}

\section{测试语句}

在导入了全部数据集后，我们选取了18条\texttt{SQL}语句进行测试，如下所示：

\begin{enumerate}[label=\textbf{\arabic*}]
  \item 根据邮箱和密码以及用户昵称注册
  \begin{lstlisting}[language=sql]
INSERT INTO "user" ("id", nickname, email, "password") VALUES (0, 'test_name', 'test_email', '13456');
  \end{lstlisting}

  \item 根据邮箱查询用户:
  \begin{lstlisting}[language=sql]
SELECT * FROM "user" WHERE email = 'test_email';
  \end{lstlisting}

  \item 根据用户传入的新密码和用户的 id 来修改密码:
  \begin{lstlisting}[language=sql]
UPDATE "user" SET "password" = '456789' WHERE id = 0;
  \end{lstlisting}

  \item 根据用户传入修改信息来对原信息进行修改:
  \begin{lstlisting}[language=sql]
UPDATE "user"
SET nickname = 'test_name2', avatar = 'dsaw', motto = 'sadw',
  collage = 'col', subscribe_email = 'true', save_history = true
WHERE id = 0;
  \end{lstlisting}

  \item 根据用户的 ID 和期刊的名称实现用户订阅感兴趣的期刊:
  \begin{lstlisting}[language=sql]
INSERT INTO subscribe (user_id, journal_name) VALUES (0, 'Respir Res');
  \end{lstlisting}

  \item 根据用户的 ID 和文献的 ID 用户实现收藏感兴趣的文献:
  \begin{lstlisting}[language=sql]
INSERT INTO "collect" (user_id, article_id) VALUES (0, 'tn4ba9le');
  \end{lstlisting}

  \item 根据用户的 ID 来实现查看用户的浏览历史:
  \begin{lstlisting}[language=sql]
SELECT * FROM "history" WHERE user_id = 0;
  \end{lstlisting}

  \item 根据作者姓名（模糊）搜索作者信息：
  \begin{lstlisting}[language=sql]
SELECT * FROM author WHERE name LIKE '%' || 'aa' || '%';
  \end{lstlisting}

  \item 根据作者姓名（模糊）搜索其撰写的文献：
  \begin{lstlisting}[language=sql]
SELECT w.author_name, ar.id, ar.title, ar.abstract, ar.doi, ar.license, ar.publish_time, ar.url
FROM "write" w
JOIN article ar ON w.article_id = ar.id
WHERE w.author_name LIKE '%' || 'aa' || '%';
  \end{lstlisting}

  \item 根据文献标题（模糊）搜索文献：
  \begin{lstlisting}[language=sql]
SELECT ar.id, ar.title, ar.abstract, ar.doi, ar.license
FROM article ar
JOIN publish p ON ar.id = p.article_id
JOIN write w ON ar.id = w.article_id
WHERE ar.title LIKE '%' || 'aa' || '%';
  \end{lstlisting}

  \item 根据期刊名模糊搜索期刊：
  \begin{lstlisting}[language=sql]
SELECT *
FROM journal
WHERE name LIKE '%' || 'Res' || '%';
  \end{lstlisting}

  \item 根据期刊名模糊搜索该期刊刊登的文章：
  \begin{lstlisting}[language=sql]
SELECT ar.*
FROM publish p
JOIN article ar ON p.article_id = ar.id
WHERE p.journal_name LIKE '%' || 'aaa' || '%';
  \end{lstlisting}

  \item 根据文献 ID 查询文献的详细信息：
  \begin{lstlisting}[language=sql]
SELECT ar.id, ar.title, ar.abstract, ar.doi, ar.license, ar.publish_time, ar.url,
  ar.study_type, ar.addressed_population, ar.challenge, ar.focus,
  p.journal_name, p.volume, p.pages
FROM article ar
JOIN publish p ON ar.id = p.article_id
WHERE ar.id = 'tn4ba9le';
  \end{lstlisting}

  \item 根据文献 ID 查询作者：
  \begin{lstlisting}[language=sql]
SELECT w.author_name
FROM article ar
JOIN write w ON ar.id = w.article_id
WHERE ar.id = 'tn4ba9le';
  \end{lstlisting}

  \item 查询文献的直接引用和间接引用：
  \begin{lstlisting}[language=sql]
WITH RECURSIVE c AS (
  SELECT citing_id, cited_id, 0 AS flag
  FROM cite
  UNION ALL
  SELECT cite.citing_id, cite.cited_id, 1 AS flag
  FROM c
  JOIN cite ON c.cited_id = cite.citing_id
)
SELECT * FROM c;
  \end{lstlisting}

  \item 测试函数\texttt{insert\_cited\_art}:
  \begin{lstlisting}[language=sql]
SELECT insert_cited_art('test_id', 'test_title', 'test_doi', '2024/6/5', 'test_journal', 'test_volume', 'test_in_pages', '0;1');
  \end{lstlisting}

  \item 测试函数\texttt{insert\_extend\_art}:
  \begin{lstlisting}[language=sql]
SELECT insert_extend_art('test_id', 't_title', '2024/6/5', 't_url', 't_type', 't_addr', 't_cha', 't_focus', 't_journal');
  \end{lstlisting}
\end{enumerate}

\section{测试结果}

我们使用 \texttt{EXPALIN} 命令来查看每条 \texttt{SQL} 语句的执行计划，以评估其性能。我们将测试结果汇总如表 \ref{tab:performance} 所示。

\begin{table}[H]
  \caption{性能测试结果}
  \centering
\label{tab:performance}
\begin{tabular}{cc}
\toprule
\textbf{序号} &  \textbf{执行时间/ms} \\ 
\midrule
1	&34 \\
2	&32 \\
3	&32 \\
4	&32 \\
5	&34 \\
6	&32 \\
7	&31 \\
8	&389 \\
9	&1028 \\
10&	2063 \\
11&	441 \\
12&	362 \\
13&	526 \\
14&	158 \\
15&	505 \\
16&	36 \\
17&	270.68 \\
18&	270.865 \\
\bottomrule
\end{tabular}
\end{table}

\section{性能分析与优化}

从表 \ref{tab:performance} 中可以看出，大部分 \texttt{SQL} 语句的执行时间都在 1000ms 以内，性能较好。但是，有两条 \texttt{SQL} 语句的执行时间较长，分别为 2063ms 和 1028ms。这是因为这两条 \texttt{SQL} 语句中包含了多个表的连接查询，导致了性能下降。我们可以通过增加索引来提高性能。

在增加了索引后，我们再次进行了测试，结果如表 \ref{tab:performance2} 所示。

\begin{longtable}[c]{cc}
  \caption{性能测试结果（优化后）} \label{tab:performance2} \\
\toprule
\textbf{序号} &  \textbf{执行时间/ms} \\
\midrule
\endfirsthead

\caption[]{性能测试结果（优化后） (续表)} \\
\toprule
\textbf{序号} &  \textbf{执行时间/ms} \\
\midrule
\endhead

\midrule
\multicolumn{2}{r}{续下页}
\endfoot

\bottomrule
\endlastfoot

1	&36 \\
2	&34 \\
3	&37 \\
4	&36 \\
5	&38 \\
6	&36 \\
7	&36 \\
8	&66 \\
9	&956 \\
10&	639 \\
11&	350 \\
12&	118 \\
13&	417 \\
14&	39 \\
15&	35 \\
16&	37 \\
17&	3.27 \\
18&	0.824 \\
\end{longtable}

从表 \ref{tab:performance2} 中可以看出，经过优化后，性能有一定的提升。其中，第 10 条 \texttt{SQL} 语句的执行时间从 2063ms 降低到 639ms。这说明增加索引对性能有一定的提升作用。改进后的性能已经可以满足系统的需求。

两次测试的对比结果如下图所示。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{img/time.png}
  \caption{性能测试结果对比}
  \label{fig:performance}
\end{figure}

\chapter{平台}
\label{sec:platform}

\section{硬件环境}

在项目进入开发后，我们使用了云服务器进行部署。我们选择并购置了一台阿里云的云服务器，具体配置如下：

\begin{itemize}
    \item 规格：ecs.e-c1m4.xlarge
    \item CPU：4 cores (vCPU)
    \item 内存：16GiB
    \item 硬盘：100GiB ESSD Entry云盘 (2600 IOPS)
    \item 网络：10Mbps 专有网络
    
\end{itemize}

\section{软件环境}

\subsection{操作系统}

我们考虑使用Ubuntu作为操作系统，具体配置如下：

\begin{itemize}
    \item 系统：Ubuntu 22.04 64位
    \item 内核：5.4.0-1045-aws
    \item 架构：x86
\end{itemize}

\subsection{编程语言及库}

我们采用数据处理、前端、后端分离的开发模式，以便于团队分工协作。具体使用的编程语言及库如下：

\subsubsection{数据}

在开发前期，我们使用了Python进行数据处理，并将SQL语句内嵌到后端代码中，以实现对数据进行增删改查。

在编写SQL时，我们惊奇地发现即使是效率极大程度上优于MySQL的PostgreSQL，在面对千万级的数据集效率也显得十分低下。因此，我们考虑加入一些插件来提高PostgreSQL的效率，并拓展其功能。

具体使用的插件如下：

\begin{table}[H]
    \centering
    \begin{tabular}{cc}
    \toprule
    \textbf{插件} &  \textbf{用途} \\ 
    \midrule
    pg\_cron & 用于定时任务的插件 \\
    pg\_trgm & 用于模糊搜索的插件 \\
    \bottomrule
    \end{tabular}
    \caption{PostgreSQL插件}
\end{table}

\subsubsection{前端}

前端部分采用的编程语言为TypeScript，开发框架为React。

前端部分的技术栈如下：

\begin{table}[H]
    \centering
    \begin{tabular}{cc}
    \toprule
    \textbf{库} &  \textbf{用途} \\ 
    \midrule
    React & 用于构建用户界面的库 \\
    Material-UI & 用于构建UI组件的库 \\
    Axios & 用于发送HTTP请求的库 \\
    \bottomrule
    \end{tabular}
    \caption{前端技术栈}
\end{table}

\subsubsection{后端}

后端部分采用的编程语言为C\#，开发框架为ASP.NET Core。

后端部分的技术栈如下：

\begin{table}[H]
    \centering
    \begin{tabular}{cc}
    \toprule
    \textbf{库} &  \textbf{用途} \\ 
    \midrule
    ASP.NET Core & 用于构建Web应用程序的框架 \\
    Entity Framework Core & 用于访问数据库的对象关系映射（ORM）框架 \\
    AutoMapper & 用于对象映射的库 \\
    JWT Token & 用于认证的令牌 \\
    Swagger & 用于生成API文档的库 \\
    MemoryCache & 用于缓存数据的库 \\
    EmailSender & 用于发送邮件的库 \\
    \bottomrule
    \end{tabular}
    \caption{后端技术栈}
\end{table}

\subsection{开发环境}

我们主要采用的开发环境如下：

\begin{table}[H]
    \centering
    \begin{tabular}{cc}
    \toprule
    \textbf{工具} &  \textbf{用途} \\ 
    \midrule
    Visual Studio Code & 代码编辑器 \\
    Git & 版本控制系统 \\
    Docker & 应用程序平台 \\
    PostgreSQL & 数据库管理系统 \\
    Navicat & 数据库管理工具 \\
    \bottomrule
    \end{tabular}
    \caption{开发环境}
\end{table}


\chapter{调优}
\label{sec:tuning}

\section{数据库调优}

首先，我们对于表结构进行了优化。在我们设计数据库时，我们尽量避免了使用过多的冗余字段，以减少数据冗余。

但是，对于\textit{article}表，我们采取了加入冗余字段来提高数据库的效率。\textit{article}表的设计起初是这样的：

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{id} & \texttt{VARCHAR(50)} & 是 &  & 文章ID \\
        \hline
        \textit{title} & \texttt{VARCHAR(1000)} &  &  & 文章标题 \\
        \hline
        \textit{abstract} & \texttt{TEXT} &  &  & 摘要 \\
        \hline
        \textit{doi} & \texttt{VARCHAR(50)} &  &  & 数字对象唯一标识符 \\
        \hline
        \textit{license} & \texttt{VARCHAR(50)} &  &  & 许可 \\
        \hline
        \textit{publish\_time} & \texttt{DATETIME} &  &  & 发表时间 \\
        \hline
        \textit{url} & \texttt{VARCHAR(800)} &  &  & 文章URL \\
        \hline
        \textit{study\_type} & \texttt{VARCHAR(500)} &  &  & 研究类型 \\
        \hline
        \textit{addressed\_population} & \texttt{VARCHAR(1000)} &  &  & 研究对象人群 \\
        \hline
        \textit{challenge} & \texttt{VARCHAR(2000)} &  &  & 挑战/研究问题 \\
        \hline
        \textit{focus} & \texttt{VARCHAR(100)} &  &  & 研究重点 \\
        \hline
    \end{tabular}
    \caption{文章(\textit{article})表}
\end{table}

考虑到\textit{article}表数据量较大($10^8$)，为了避免\textit{article}表与\textit{write}表\texttt{JOIN}时消耗过长的时间，我们考虑为\textit{article}加入冗余字段\textit{authors}。

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{字段名} & \textbf{类型} & \textbf{主键} & \textbf{外键} & \textbf{说明} \\
        \hline
        \textit{...} & \texttt{...} &  &  & ... \\
        \hline
        \textit{authors} & \texttt{TEXT} &  &  & 作者 \\
        \hline
    \end{tabular}
    \caption{文章(\textit{article})续表}
\end{table}

在查询文章或作者时，只需要利用\texttt{LIKE}语句查询\textit{article}表，而不需要\texttt{JOIN}操作，从而期望提高查询效率。经过多次测试与验证，我们确信这样\textbf{以空间换时间}的方式是\textbf{十分有必要的}。

其次，在编写查询文章的代码时，我们发现\texttt{LIKE}的效率较低，在全数据集上经常超时(超过30s)，建立相应的索引后，我们发现仍然不能改善这一问题。但进行模糊查询不可避免要使用到\texttt{LIKE}语句。这不得不让我们思考如何提高\texttt{LIKE}的效率。

通过\texttt{EXPLAIN}语句检查这些语句的执行计划，发现它们采用顺序扫描而未曾使用索引。同时我们上网查询得知，\texttt{LIKE}语句确实采用顺序扫描而非索引检索的方式获取内容。经过一系列网络资料的查询后，我们最终确定导入\textit{trgm}插件，使用其提供的\texttt{GIN}索引来优化模糊查询。

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{表名} & \textbf{字段名} & \textbf{说明} \\
        \hline
        \textit{article} & \textit{authors} & 作者 \\
        \hline
        \textit{article} & \textit{title} & 文章标题 \\
        \hline
        \textit{author} & \textit{name} & 作者姓名 \\
        \hline
        \textit{journal} & \textit{name} & 期刊名 \\
        \hline
        \textit{publish} & \textit{journal\_name} & 期刊名 \\
        \hline
        \textit{write} & \textit{author\_name} & 作者姓名 \\
        \hline
    \end{tabular}
    \caption{采用\texttt{GIN}索引的属性}
\end{table}

经过多次测试与验证，我们发现原本超时(超过30s)的SQL语句，经过\texttt{GIN}索引的优化后，查询时间缩短到了1s，效率得到了显著提高。因此，我们确信\textbf{采用\texttt{GIN}索引}的方式也是\textbf{很有必要的}。

最后，我们对于数据库中各个表的不同字段都建立了不同的索引，以期优化查询效率。具体的索引如下表所示。

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{表名} & \textbf{字段名} & \textbf{索引方法} & \textbf{说明} \\
        \hline
        \textit{article} & \textit{id} & \texttt{btree} & 文章ID \\
        \hline
        \textit{article} & \textit{title} & \texttt{btree} & 文章标题 \\
        \hline
        \textit{article} & \textit{url} & \texttt{btree} & 文章URL \\
        \hline
        \textit{author} & \textit{name} & \texttt{btree} & 作者姓名 \\
        \hline
        \textit{cite} & \textit{cited\_id} & \texttt{btree} & 被引用的文章id \\
        \hline
        \textit{cite} & \textit{citing\_id} & \texttt{btree} & 引用的文章id \\
        \hline
        \textit{journal} & \textit{name} & \texttt{btree} & 期刊名 \\
        \hline
        \textit{publish} & \textit{article\_id} & \texttt{btree} & 文章ID \\
        \hline
        \textit{publish} & \textit{journal\_name} & \texttt{btree} & 期刊名 \\
        \hline
        \textit{write} & \textit{article\_id} & \texttt{btree} & 文章ID \\
        \hline
    \end{tabular}
    \caption{所建立的索引}
\end{table}

显然，这些索引在提高查询效率方面起到了重要作用。

\section{SQL语句优化}

在开发过程中，我们对大量SQL语句进行了优化，以期提高查询效率。下面，我们将举例两个优化效果最显著的SQL语句进行说明。

\subsection{LIKE语句优化}

编写后端代码时，我们考虑将模糊查询文章标题、作者、期刊合并为同一个接口，这对我们的数据库查询带来了挑战。最初，我们采用原始的\texttt{LIKE}语句进行模糊查询，SQL语句如下：

\begin{lstlisting}[language=sql]
SELECT
	article.*,
	publish.* 
FROM
	article
	JOIN publish ON article.ID = publish.article_id 
WHERE
	( article.title LIKE'%{?}%' OR article.authors LIKE'%{?}%' OR journal_name LIKE'%{?}%' ) 
ORDER BY
	publish_time DESC；
\end{lstlisting}

这一语句在全量数据集中的千万级表\textit{article}和千万级表\textit{publish}上执行时，效率较低，必然超时。我们考虑使用\texttt{GIN}索引优化语句，但效果不明显，结合\texttt{EXPALIN}语句分析我们推测是因为索引未被使用，通过上网查询证实了我们的猜想。由具体资料指出，\texttt{WHERE}子句中包含\texttt{OR}将导致语句不使用索引。因此，我们考虑采用UNION来代替实现or的功能，这样对于目标关键词的模糊查询将会使用索引，以期使效率提升。

\begin{lstlisting}[language=sql]
    SELECT
    article.*,
    publish.* 
  FROM
    article
    JOIN publish ON article.ID = publish.article_id 
  WHERE
    article.title LIKE'%diabetes%' UNION
  SELECT
    article.*,
    publish.* 
  FROM
    article
    JOIN publish ON article.ID = publish.article_id 
  WHERE
    article.authors LIKE'%diabetes%' UNION
  SELECT
    article.*,
    publish.* 
  FROM
    article
    JOIN publish ON article.ID = publish.article_id 
  WHERE
    journal_name LIKE'%diabetes%' 
  ORDER BY
    publish_time DESC;
\end{lstlisting}

经过多次测试与验证，我们发现优化后的SQL语句成功正确使用了\texttt{GIN}索引，原本超时(超过30s)的SQL语句，经过索引及\texttt{UNION}的优化后，查询时间缩短到了1s，效率得到了显著提高，这证明我们的优化工作是成功的。

\subsection{非空判断优化}

在编写SQL时，我们对于一个属性是否为空的判断，我们采用了\texttt{IS NOT NULL}的方式。比如，在实现对文章url是否存在时，我们使用了如下面所示的代码：

\begin{lstlisting}[language=sql]
SELECT
  article.*,
  publish.* 
FROM
  article
  JOIN publish ON article.ID = publish.article_id 
WHERE
  article.title LIKE {?} AND article.url IS NOT NULL;
\end{lstlisting}

但是，我们发现\texttt{IS NOT NULL}的效率较低，我们考虑使用\texttt{COALESCE}函数来代替\texttt{IS NOT NULL}，以期提高查询效率。我们修改为如下的代码：

\begin{lstlisting}[language=sql]
SELECT
  article.*,
  publish.* 
FROM
  article
  JOIN publish ON article.ID = publish.article_id 
WHERE
  article.title LIKE {?} AND AND COALESCE(article.url, '111') <> '111';
\end{lstlisting}

经过多次测试与验证，我们发现优化后的SQL语句成功提高了将近$\frac{1}{3}$的效率，这证明我们对非空判断的优化工作是成功的。

\chapter{总结}
\label{sec:conclusion}

在此项目中，我们设计了一个有关Covid(新冠病毒)的论文查询网站，实现了对千万级别数据库的高效查询功能与用户的收藏订阅。我们首先设计了数据库，然后使用Python对数据进行处理，将数据导入到数据库中。数据库设计中，我们使用了PostgreSQL作为数据库，编写了数十个SQL查询语句，并使用pgSQL编写了存储过程和函数。开发方面，我们使用了C\#作为后端语言，集成了ASP.NET Core框架；使用TypeScript作为前端语言，集成了React框架。平台方面，我们使用了阿里云服务器进行部署，使用Ubuntu作为操作系统，使用Docker作为应用程序平台，成功将可执行文件发布到Docker Hub\footnote{\url{https://hub.docker.com/r/pdli/covidlit-search}}，并集成Github Actions实现自动化部署。调优方面，我们对数据库进行了调优，包括对表结构的优化、对SQL语句的优化、对索引的优化等，以提高查询效率。最终，我们成功高效实现了整个网站\footnote{\url{https://covidlit-search.pdli.site}}，并对其进行了合理的性能测试，达到了预期的效果。项目丰富了我们的数据库设计、数据处理、前后端开发、平台部署、调优等方面的经验，是一次十分有意义的实践。

\newpage

\appendix

\chapter{所附代码文件概述}
\label{appendix:code}

随本报告所附代码文件结构如下：

\begin{figure}[H]
  \dirtree{%
      .1 DBProject.
      .2 archive/\DTcomment{图 \ref{fig:dataset} 所示的数据集}.
      .2 data\_process.
      .3 output/.
      .4 deduplicated/\DTcomment{去重后的数据}.
      .3 article.py\DTcomment{文献所包含的类}.
      .3 main.py\DTcomment{主程序}.
      .3 requirements.txt\DTcomment{依赖}.
      .3 README.md\DTcomment{使用说明}.
      .2 backend/\DTcomment{后端代码}.
      .3 README.md\DTcomment{使用说明}.
      .3 $\dots$.
      .2 frontend/\DTcomment{前端代码}.
      .3 README.md\DTcomment{使用说明}.
      .3 $\dots$.
      .2 test/\DTcomment{测试代码}.
      .3 test-sample.sql.
      .3 test-sample.out.
      .3 test-production.sql.
      .3 test-production.out.
      .2 README.md\DTcomment{总使用说明}.
  }
  \caption{所附代码文件结构}
  \label{fig:processData}
\end{figure}

\newpage

\chapter{Milestone 2在Milestone 1基础的变化}

\begin{enumerate}
    \item 在 \ref{sec:overviewOfDatabaseDesign} 节中，我们更换了使用的数据库管理系统，从MySQL变为PostgreSQL。
    \item 在 \ref{sec:dataProcessing} 节中，我们更改了数据处理的方式，先将数据处理后存储到本地文件中，再使用数据库的 \texttt{COPY} 命令批量插入数据，以提高性能。
    \item 在第 \ref{sec:sql} 章中，我们修改了函数/存储过程的代码和部分 \texttt{SQL} 语句，以符合PostgreSQL的语法。
    \item 增加了第 \ref{sec:performance} 章，对系统的性能进行了测试和分析。
    \item 增加了附录\ref{appendix:code}，展示了所附代码文件的结构和使用方法。
\end{enumerate}

\newpage

\chapter{Final Report在Milestone 2基础的变化}

\begin{enumerate}
    \item 在 \ref{sec:entities} 节中，我们为\textit{article}表增加了\textit{authors}属性以存储作者信息。
    \item 在 \ref{sec:er} 节中，我们修改了ER图，增加了\textit{authors}属性。
    \item 在 \ref{sec:schema} 节中，我们修改了\textit{article}表的模式，增加了\textit{authors}属性。
    \item 增加了第 \ref{sec:platform} 章，展示了系统的硬件环境、软件环境和开发环境。
    \item 增加了第 \ref{sec:tuning} 章，展示了数据库调优和SQL语句优化的过程。
    \item 增加了第 \ref{sec:conclusion} 章，总结了本次项目。
\end{enumerate}


\end{document}